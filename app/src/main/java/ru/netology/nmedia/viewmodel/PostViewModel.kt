package ru.netology.nmedia.viewmodelimport android.app.Applicationimport androidx.lifecycle.AndroidViewModelimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport ru.netology.nmedia.dto.Postimport ru.netology.nmedia.repository.PostRepositoryimport ru.netology.nmedia.repository.PostRepositoryFileImplimport ru.netology.nmedia.util.SingleLiveEventimport java.io.IOExceptionimport kotlin.concurrent.threadprivate val empty = Post(0,"Me","",0,false,0)class PostViewModel(application: Application) : AndroidViewModel(application) {private val repository: PostRepository = PostRepositoryFileImpl()    private val _data = MutableLiveData(FeedModel())    val data: LiveData<FeedModel>    get() = _data    val edited = MutableLiveData(empty)    private val _postCreated = SingleLiveEvent<Unit>()    val postCreated: LiveData<Unit>    get() = _postCreated    init {        loadPosts()    }    fun loadPosts() {        thread {            _data.postValue(FeedModel(loading = true))            try{                val posts = repository.getAll()                FeedModel(posts = posts, empty = posts.isEmpty())            } catch (e: IOException) {                FeedModel(error = true)            }.also(_data::postValue)        }    }    fun likeById(id:Long){        thread {            val newPost= repository.likeById(id)            var posts = _data.value?.posts.orEmpty()            posts = posts.map {                if (it.id != id) it else it.copy(                        likedByMe = newPost.likedByMe,                        likes = newPost.likes)            }            _data.postValue(FeedModel(posts = posts))        }    }    fun dislikeById(id:Long) {        thread {            val newPost = repository.dislikeById(id)            var posts = _data.value?.posts.orEmpty()            posts = posts.map {                if (it.id != id) it else it.copy(                    likedByMe = newPost.likedByMe,                    likes = newPost.likes)            }            _data.postValue(FeedModel(posts = posts))        }    }        fun sharedById(id: Long) {            thread {                val old = _data.value?.posts.orEmpty()                val posts = _data.value?.posts.orEmpty()                posts.map {                    if (it.id != id) it else it.copy()                }                try {                    repository.sharedById(id)                } catch (e: IOException) {                    _data.postValue(_data.value?.copy(posts = old))                }            }        }        fun refresh() {            loadPosts()        }        fun removeById(id: Long) {            thread {                val old = _data.value?.posts.orEmpty()                _data.postValue(                    _data.value?.copy(posts = _data.value?.posts.orEmpty()                        .filter { it.id != id }                    )                )                try {                    repository.removeById(id)                } catch (e: IOException) {                    _data.postValue(_data.value?.copy(posts = old))                }            }        }        fun save() {            thread {                edited.value?.let {                    repository.save(it)                    _postCreated.postValue(Unit)                }                edited.postValue(empty)            }        }        fun edit(post: Post) {            edited.value = post        }        fun editContent(content: String) {            edited.value.let {                val trimmed = content.trim()                if (edited.value?.content == trimmed) {                    return                }                edited.value = edited.value?.copy(content = trimmed)            }        }    }