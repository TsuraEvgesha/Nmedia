package ru.netology.nmedia.viewmodelimport android.app.Applicationimport androidx.lifecycle.*import kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.flow.catchimport kotlinx.coroutines.flow.mapimport kotlinx.coroutines.launchimport ru.netology.nmedia.dao.AppDbimport ru.netology.nmedia.dto.Postimport ru.netology.nmedia.repository.PostRepositoryimport ru.netology.nmedia.repository.PostRepositoryFileImplimport ru.netology.nmedia.util.SingleLiveEvent//private const val JOB_KEY = "androidx.lifecycle.ViewModelCoroutineScope.JOB_KEY"private val empty = Post(0,"Me","","",0,false,0, false,null)class PostViewModel(application: Application) : AndroidViewModel(application) {    private val repository: PostRepository =        PostRepositoryFileImpl(AppDb.getInstance(context = application).postDao())    val data: LiveData<FeedModel> = repository.data        .map(::FeedModel)        .catch { e->            e.printStackTrace()        }        .asLiveData(Dispatchers.Default)//    fun <T> Flow<T>.asLiveData(//        context:CoroutineContext = EmptyCoroutineContext,//        timeoutInMs: Long = DEFAULT_TIMEOUT//    ): LiveData<T> = liveData(context,timeoutInMs){//        collect{//            emit(it)//        }//    } реализация функции asLiveData    val newerCount: LiveData<Int> = data.switchMap{        repository.getNewerCount(it.posts.firstOrNull()?.id ?: 0L)            .asLiveData(Dispatchers.Default)    }    private val _dataState = MutableLiveData(FeedModelState(idle = true))    private val edited = MutableLiveData(empty)    private val _postCreated = SingleLiveEvent<Unit>()    val postCreated: LiveData<Unit>    get() = _postCreated//    private val _requestCode = MutableLiveData<Int>()//    val requestCode: LiveData<Int> = _requestCode    val dataState: LiveData<FeedModelState>        get() = _dataState    init {        loadPosts()    }    fun loadPosts() = viewModelScope.launch {        _dataState.value = FeedModelState(loading = true)        try {            repository.getAll()            _dataState.value= FeedModelState(idle = true)        } catch (e:Exception){            _dataState.value = FeedModelState(error = true)        }    }    fun updateStatus(){        viewModelScope.launch {            repository.updateStatus()        }    }//    override fun onCleared() {//        super.onCleared()//        scope.cancel()//    }    fun save() {    edited.value?.let {        _postCreated.value = Unit        viewModelScope.launch {            try {                repository.save(it)                _dataState.value = FeedModelState()            } catch (e: Exception) {                _dataState.value = FeedModelState(error = true)            }        }        edited.value = empty    }}    fun likeById(id:Long) {        viewModelScope.launch {            try {                repository.likeById(id)                _dataState.value = FeedModelState()            } catch (e: Exception) {                _dataState.value = FeedModelState(error = true)            }        }    }    fun dislikeById(id:Long) {        viewModelScope.launch {            try {                repository.dislikeById(id)                _dataState.value = FeedModelState()            } catch (e: Exception) {                _dataState.value = FeedModelState(error = true)            }        }    }//        fun sharedById(id: Long) {//            thread {//                val old = _data.value?.posts.orEmpty()//                val posts = _data.value?.posts.orEmpty()//                posts.map {//                    if (it.id != id) it else it.copy()//                }//                try {//                    repository.sharedById(id)//                } catch (e: IOException) {//                    _data.postValue(_data.value?.copy(posts = old))//                }//            }////        }    fun refreshPosts() = viewModelScope.launch {        try {            _dataState.value = FeedModelState(refreshing = true)            repository.getAll()            _dataState.value = FeedModelState(idle = true)        } catch (e: Exception) {            _dataState.value = FeedModelState(error = true)        }    }    fun removeById(id: Long) {        viewModelScope.launch {            try {                repository.removeById(id)                _dataState.value=FeedModelState()            }catch (e:Exception){                _dataState.value = FeedModelState(error = true)            }        }    }    fun edit(post: Post) {        edited.value = post    }    fun editContent(content: String) {        edited.value.let {            val trimmed = content.trim()            if (edited.value?.content == trimmed) {                return            }            edited.value = edited.value?.copy(content = trimmed)        }    }}